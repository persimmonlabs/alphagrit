from dataclasses import dataclass, field
from datetime import datetime
import uuid
from enum import Enum
from typing import Optional, List

# Enums from schema.sql
class OrderStatus(str, Enum):
    PENDING = "pending"
    PAID = "paid"
    REFUNDED = "refunded"
    REFUND_REQUESTED = "refund_requested"
    CANCELLED = "cancelled"

class PaymentMethod(str, Enum):
    STRIPE = "stripe"
    MERCADO_PAGO = "mercado_pago"

class CurrencyType(str, Enum):
    BRL = "BRL"
    USD = "USD"

class RefundStatus(str, Enum):
    PENDING = "pending"
    APPROVED = "approved"
    DENIED = "denied"

@dataclass
class CartItem:
    user_id: str
    product_id: str
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    quantity: int = 1
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self):
        if self.quantity <= 0:
            raise ValueError("Cart item quantity must be positive")

@dataclass
class OrderItem:
    order_id: str
    product_name: str
    price: float
    subtotal: float
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    product_id: Optional[str] = None # Now has a default
    product_slug: Optional[str] = None # Now has a default
    quantity: int = 1
    file_url: Optional[str] = None # Now has a default
    created_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self):
        if self.quantity <= 0:
            raise ValueError("Order item quantity must be positive")
        if self.price < 0:
            raise ValueError("Order item price cannot be negative")
        if self.subtotal < 0:
            raise ValueError("Order item subtotal cannot be negative")

@dataclass
class Order:
    customer_email: str
    subtotal: float
    total: float
    currency: CurrencyType
    payment_method: PaymentMethod
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    order_number: Optional[str] = field(default=None) # Generated by DB trigger
    user_id: Optional[str] = None # Now has a default
    customer_name: Optional[str] = None
    tax: float = 0.0
    payment_intent_id: Optional[str] = None
    stripe_session_id: Optional[str] = None
    mercado_pago_id: Optional[str] = None
    status: OrderStatus = OrderStatus.PENDING
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    paid_at: Optional[datetime] = None
    refunded_at: Optional[datetime] = None
    items: List[OrderItem] = field(default_factory=list) # Aggregate relationship

    def __post_init__(self):
        if self.subtotal < 0 or self.tax < 0 or self.total < 0:
            raise ValueError("Order amounts cannot be negative")
        if not self.customer_email:
            raise ValueError("Customer email is required for an order")
        # Basic check, can be more complex with floating point
        if not (self.subtotal + self.tax - self.total < 0.01 and self.subtotal + self.tax - self.total > -0.01):
             # raise ValueError("Order total does not match subtotal + tax")
             # This check can be tricky with floating point. Maybe better in application service.
             pass 

    def mark_paid(self):
        if self.status != OrderStatus.PENDING:
            raise ValueError(f"Cannot mark order as paid from status {self.status.value}")
        self.status = OrderStatus.PAID
        self.paid_at = datetime.now()
        self.updated_at = datetime.now()

    def mark_cancelled(self):
        if self.status == OrderStatus.PAID or self.status == OrderStatus.REFUNDED:
            raise ValueError(f"Cannot cancel order from status {self.status.value}")
        self.status = OrderStatus.CANCELLED
        self.updated_at = datetime.now()

@dataclass
class DownloadLink:
    order_id: str
    product_id: str
    file_url: str
    expires_at: datetime
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    user_id: Optional[str] = None
    token: str = field(default_factory=lambda: str(uuid.uuid4())) # Unique token for download
    max_downloads: int = 5
    download_count: int = 0
    last_downloaded_at: Optional[datetime] = None
    last_ip_address: Optional[str] = None
    is_active: bool = True
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)

    def __post_init__(self):
        if not self.file_url:
            raise ValueError("Download link must have a file_url")
        if self.max_downloads <= 0:
            raise ValueError("Max downloads must be positive")
        if self.download_count < 0:
            raise ValueError("Download count cannot be negative")
        if self.expires_at <= self.created_at:
            raise ValueError("Expires at must be after created at")
    
    def increment_download_count(self, ip_address: str):
        if not self.is_active:
            raise ValueError("Cannot download from an inactive link.")
        if self.download_count >= self.max_downloads:
            raise ValueError("Maximum download count reached for this link.")
        if self.expires_at <= datetime.now():
            raise ValueError("Download link has expired.")
        
        self.download_count += 1
        self.last_downloaded_at = datetime.now()
        self.last_ip_address = ip_address
        self.updated_at = datetime.now()