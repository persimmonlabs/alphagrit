from sqlalchemy import Column, String, Float, Boolean, DateTime, Integer, Text, ForeignKey, Enum as SQLEnum
from sqlalchemy.orm import relationship, joinedload
from sqlalchemy.sql import func
import uuid
from typing import Optional, List

from src.domain.entities.order import CartItem, Order, OrderItem, DownloadLink, OrderStatus, PaymentMethod, CurrencyType, RefundStatus
from src.domain.repositories.order_repository import AbstractCartRepository, AbstractOrderRepository, AbstractDownloadLinkRepository
from src.infrastructure.base import Base # Import Base from your dedicated base setup # Import Base from your database setup
from sqlalchemy.orm import Session

# SQLAlchemy ORM Models
class CartItemORM(Base):
    __tablename__ = "cart_items"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    user_id = Column(String(36), nullable=False) # REFERENCES auth.users(id) - assuming string UUID for user_id
    product_id = Column(String(36), ForeignKey("products.id"), nullable=False)
    quantity = Column(Integer, default=1, nullable=False)
    created_at = Column(DateTime(timezone=True), default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), default=func.now(), onupdate=func.now(), nullable=False)

    def to_entity(self) -> CartItem:
        return CartItem(
            id=str(self.id),
            user_id=str(self.user_id),
            product_id=str(self.product_id),
            quantity=self.quantity,
            created_at=self.created_at,
            updated_at=self.updated_at
        )

    @staticmethod
    def from_entity(entity: CartItem) -> 'CartItemORM':
        return CartItemORM(
            id=entity.id,
            user_id=entity.user_id,
            product_id=entity.product_id,
            quantity=entity.quantity,
            created_at=entity.created_at,
            updated_at=entity.updated_at
        )

class OrderItemORM(Base):
    __tablename__ = "order_items"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    order_id = Column(String(36), ForeignKey("orders.id"), nullable=False)
    product_id = Column(String(36), ForeignKey("products.id"), nullable=True) # Can be null if product is deleted
    product_name = Column(String(255), nullable=False)
    product_slug = Column(String(255), nullable=True)
    price = Column(Float, nullable=False)
    quantity = Column(Integer, default=1, nullable=False)
    subtotal = Column(Float, nullable=False)
    file_url = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), default=func.now(), nullable=False)

    order = relationship("OrderORM", back_populates="items")

    def to_entity(self) -> OrderItem:
        return OrderItem(
            id=str(self.id),
            order_id=str(self.order_id),
            product_id=str(self.product_id) if self.product_id else None,
            product_name=self.product_name,
            product_slug=self.product_slug,
            price=self.price,
            quantity=self.quantity,
            subtotal=self.subtotal,
            file_url=self.file_url,
            created_at=self.created_at
        )

    @staticmethod
    def from_entity(entity: OrderItem) -> 'OrderItemORM':
        return OrderItemORM(
            id=entity.id,
            order_id=entity.order_id,
            product_id=entity.product_id,
            product_name=entity.product_name,
            product_slug=entity.product_slug,
            price=entity.price,
            quantity=entity.quantity,
            subtotal=entity.subtotal,
            file_url=entity.file_url,
            created_at=entity.created_at
        )

class OrderORM(Base):
    __tablename__ = "orders"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    order_number = Column(String(50), unique=True, nullable=True) # Generated by DB trigger, can be null initially
    user_id = Column(String(36), nullable=True) # REFERENCES auth.users(id)
    customer_email = Column(String(255), nullable=False)
    customer_name = Column(String(255), nullable=True)
    subtotal = Column(Float, nullable=False)
    tax = Column(Float, default=0.0, nullable=False)
    total = Column(Float, nullable=False)
    currency = Column(SQLEnum(CurrencyType, name="currency_type", create_type=False), nullable=False)
    payment_method = Column(SQLEnum(PaymentMethod, name="payment_method", create_type=False), nullable=False)
    payment_intent_id = Column(String(255), nullable=True)
    stripe_session_id = Column(String(255), nullable=True)
    mercado_pago_id = Column(String(255), nullable=True)
    status = Column(SQLEnum(OrderStatus, name="order_status", create_type=False), default=OrderStatus.PENDING, nullable=False)
    ip_address = Column(String(45), nullable=True) # INET type not directly supported by SQLite, use String
    user_agent = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), default=func.now(), onupdate=func.now(), nullable=False)
    paid_at = Column(DateTime(timezone=True), nullable=True)
    refunded_at = Column(DateTime(timezone=True), nullable=True)

    items = relationship("OrderItemORM", back_populates="order", cascade="all, delete-orphan")

    def to_entity(self) -> Order:
        return Order(
            id=str(self.id),
            order_number=self.order_number,
            user_id=str(self.user_id) if self.user_id else None,
            customer_email=self.customer_email,
            customer_name=self.customer_name,
            subtotal=self.subtotal,
            tax=self.tax,
            total=self.total,
            currency=self.currency,
            payment_method=self.payment_method,
            payment_intent_id=self.payment_intent_id,
            stripe_session_id=self.stripe_session_id,
            mercado_pago_id=self.mercado_pago_id,
            status=self.status,
            ip_address=self.ip_address,
            user_agent=self.user_agent,
            created_at=self.created_at,
            updated_at=self.updated_at,
            paid_at=self.paid_at,
            refunded_at=self.refunded_at,
            items=[item_orm.to_entity() for item_orm in self.items] if self.items else []
        )

    @staticmethod
    def from_entity(entity: Order) -> 'OrderORM':
        return OrderORM(
            id=entity.id,
            order_number=entity.order_number,
            user_id=entity.user_id,
            customer_email=entity.customer_email,
            customer_name=entity.customer_name,
            subtotal=entity.subtotal,
            tax=entity.tax,
            total=entity.total,
            currency=entity.currency,
            payment_method=entity.payment_method,
            payment_intent_id=entity.payment_intent_id,
            stripe_session_id=entity.stripe_session_id,
            mercado_pago_id=entity.mercado_pago_id,
            status=entity.status,
            ip_address=entity.ip_address,
            user_agent=entity.user_agent,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
            paid_at=entity.paid_at,
            refunded_at=entity.refunded_at,
            # Items need to be handled separately for saving/updating relationships
            # They are not directly passed to the OrderORM constructor this way
        )

class DownloadLinkORM(Base):
    __tablename__ = "download_links"

    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    order_id = Column(String(36), ForeignKey("orders.id"), nullable=False)
    product_id = Column(String(36), ForeignKey("products.id"), nullable=False)
    user_id = Column(String(36), nullable=True) # REFERENCES auth.users(id)
    token = Column(String(255), unique=True, nullable=False, default=lambda: str(uuid.uuid4()))
    file_url = Column(Text, nullable=False)
    max_downloads = Column(Integer, default=5, nullable=False)
    download_count = Column(Integer, default=0, nullable=False)
    expires_at = Column(DateTime(timezone=True), nullable=False)
    last_downloaded_at = Column(DateTime(timezone=True), nullable=True)
    last_ip_address = Column(String(45), nullable=True) # INET type not directly supported by SQLite, use String
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), default=func.now(), onupdate=func.now(), nullable=False)

    order = relationship("OrderORM") # unidirectional or bidirecional?

    def to_entity(self) -> DownloadLink:
        return DownloadLink(
            id=str(self.id),
            order_id=str(self.order_id),
            product_id=str(self.product_id),
            user_id=str(self.user_id) if self.user_id else None,
            token=self.token,
            file_url=self.file_url,
            max_downloads=self.max_downloads,
            download_count=self.download_count,
            expires_at=self.expires_at,
            last_downloaded_at=self.last_downloaded_at,
            last_ip_address=self.last_ip_address,
            is_active=self.is_active,
            created_at=self.created_at,
            updated_at=self.updated_at
        )

    @staticmethod
    def from_entity(entity: DownloadLink) -> 'DownloadLinkORM':
        return DownloadLinkORM(
            id=entity.id,
            order_id=entity.order_id,
            product_id=entity.product_id,
            user_id=entity.user_id,
            token=entity.token,
            file_url=entity.file_url,
            max_downloads=entity.max_downloads,
            download_count=entity.download_count,
            expires_at=entity.expires_at,
            last_downloaded_at=entity.last_downloaded_at,
            last_ip_address=entity.last_ip_address,
            is_active=entity.is_active,
            created_at=entity.created_at,
            updated_at=entity.updated_at
        )

# SQLAlchemy Repository Implementations
class SQLAlchemyCartRepository(AbstractCartRepository):
    def __init__(self, session: Session):
        self.session = session

    def get_by_user_id(self, user_id: str) -> List[CartItem]:
        orm_items = self.session.query(CartItemORM).filter_by(user_id=user_id).all()
        return [item.to_entity() for item in orm_items]

    def get_item_by_user_and_product(self, user_id: str, product_id: str) -> Optional[CartItem]:
        # Assuming product_id here is actually the cart_item_id for update/remove operations as per service call
        # This needs clarification if the service is passing product_id or cart_item_id for update/remove
        # For now, let's assume it means get an item by its ID.
        # If it truly means user_id + product_id, then:
        orm_item = self.session.query(CartItemORM).filter_by(user_id=user_id, product_id=product_id).first()
        # If the service passes cart_item_id as product_id, then:
        # orm_item = self.session.query(CartItemORM).filter_by(id=product_id, user_id=user_id).first()
        return orm_item.to_entity() if orm_item else None

    def save(self, cart_item: CartItem) -> None:
        orm_item = self.session.query(CartItemORM).filter_by(id=cart_item.id).first()
        if orm_item:
            # Update existing
            for key, value in CartItemORM.from_entity(cart_item).__dict__.items():
                if not key.startswith('_'):
                    setattr(orm_item, key, value)
        else:
            # Add new
            self.session.add(CartItemORM.from_entity(cart_item))
        self.session.commit()

    def delete(self, cart_item_id: str) -> None:
        self.session.query(CartItemORM).filter_by(id=cart_item_id).delete()
        self.session.commit()
    
    def clear_cart(self, user_id: str) -> None:
        self.session.query(CartItemORM).filter_by(user_id=user_id).delete()
        self.session.commit()


class SQLAlchemyOrderRepository(AbstractOrderRepository):
    def __init__(self, session: Session):
        self.session = session

    def get_by_id(self, order_id: str) -> Optional[Order]:
        orm_order = self.session.query(OrderORM).options(joinedload(OrderORM.items)).filter_by(id=order_id).first()
        if orm_order:
            return orm_order.to_entity()
        return None
    
    def get_by_order_number(self, order_number: str) -> Optional[Order]:
        orm_order = self.session.query(OrderORM).options(joinedload(OrderORM.items)).filter_by(order_number=order_number).first()
        if orm_order:
            return orm_order.to_entity()
        return None

    def get_all(self, user_id: Optional[str] = None, status: Optional[OrderStatus] = None) -> List[Order]:
        query = self.session.query(OrderORM).options(joinedload(OrderORM.items))
        if user_id:
            query = query.filter_by(user_id=user_id)
        if status:
            query = query.filter_by(status=status)
        
        orm_orders = query.all()
        return [order.to_entity() for order in orm_orders]

    def save(self, order: Order) -> None:
        orm_order = self.session.query(OrderORM).filter_by(id=order.id).first()
        if orm_order:
            # Update existing scalar attributes
            for key, value in OrderORM.from_entity(order).__dict__.items():
                if not key.startswith('_') and key != 'items':
                    setattr(orm_order, key, value)
            
            # Handle nested items relationship for updates
            # This is complex and usually requires a dedicated approach (e.g., merge, delete-orphan cascade)
            # For simplicity in initial setup, we'll assume items are managed by order creation/updates
            # and might need more advanced handling for modifying existing order_items.
            # Currently, 'cascade="all, delete-orphan"' is set on the relationship, which helps.
            # Clear existing items and re-add from entity
            orm_order.items = []
            for item_entity in order.items:
                orm_order.items.append(OrderItemORM.from_entity(item_entity))
        else:
            # Add new order and its items
            new_orm_order = OrderORM.from_entity(order)
            new_orm_order.items = [OrderItemORM.from_entity(item) for item in order.items]
            self.session.add(new_orm_order)
        self.session.commit()

    def delete(self, order_id: str) -> None:
        orm_order = self.session.query(OrderORM).filter_by(id=order_id).first()
        if orm_order:
            self.session.delete(orm_order)
            self.session.commit()


class SQLAlchemyDownloadLinkRepository(AbstractDownloadLinkRepository):
    def __init__(self, session: Session):
        self.session = session

    def get_by_id(self, link_id: str) -> Optional[DownloadLink]:
        orm_link = self.session.query(DownloadLinkORM).filter_by(id=link_id).first()
        return orm_link.to_entity() if orm_link else None

    def get_by_token(self, token: str) -> Optional[DownloadLink]:
        orm_link = self.session.query(DownloadLinkORM).filter_by(token=token).first()
        return orm_link.to_entity() if orm_link else None

    def get_by_order_and_product(self, order_id: str, product_id: str) -> Optional[DownloadLink]:
        orm_link = self.session.query(DownloadLinkORM).filter_by(order_id=order_id, product_id=product_id).first()
        return orm_link.to_entity() if orm_link else None

    def save(self, download_link: DownloadLink) -> None:
        orm_link = self.session.query(DownloadLinkORM).filter_by(id=download_link.id).first()
        if orm_link:
            # Update existing
            for key, value in DownloadLinkORM.from_entity(download_link).__dict__.items():
                if not key.startswith('_'):
                    setattr(orm_link, key, value)
        else:
            # Add new
            self.session.add(DownloadLinkORM.from_entity(download_link))
        self.session.commit()

    def delete(self, link_id: str) -> None:
        self.session.query(DownloadLinkORM).filter_by(id=link_id).delete()
        self.session.commit()